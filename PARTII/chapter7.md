# 第七章 事物处理
事物处理是为了满足下面几条而将多个操作合并成一个事物一并处理。
## ACID
1. **Atomicity**：原子性意味着，多个写操作必须一起执行，要么都执行成功要么都执行失败。如果执行过程中系统出现故障，系统必须抛弃之前所做的所有写操作。
2. **Consistency**：稳定性，
3. **Isolation**：孤立性，并发执行的操作互相不影响。
4. **Durability**：耐久性，不需要担心数据丢失

## 单对象和多对象操作
这里主要考虑：原子性和孤立性。
### 单对象操作
原子性：可以使用log记录来保证。
孤立性：可以用一个锁来处理。
### 多对象操作
需要事物处理。

## 弱孤立等级
使用序列化可以避免孤立性问题。但是对性能影响太大，所以很多系统使用弱孤立等级。
## read commit等级
1. 读只会读到commit了的数据。（没有**dirty read**）
2. 写只会覆盖commit了的数据。（没有**dierty writes**）
多次赋值只有当全部完成才会commit。可以避免读到中间值和写入时覆盖半完成状态。写可以使用一个全局锁实现，读则在有锁时只读旧数据。
## snapshot isolation and repeatable read
重复读时如果中间发生写操作，可能读到不一致数据。特别是在备份或者分析时。这时候需要快照隔离。保证读取到的数据是开始读时刻的快照。 
快照隔离实现方法：`每次操作有一个递增的事物ID，读取数据的时候，只能读取到已经确认的事物的修改。`
## 避免更新丢失
上面梁总弱孤立等级只考虑了同时读。
**原子操作（atmoic writes）**：使用一个锁来防止同时写。
还有可以使得写只有在读取后没有发生改变的情况下才能发生。
对多Leader的系统，因为写入已经发生，所以只先产生兄弟版本，后面使用特殊手段解除冲突。

## 写偏序和幻影
互相依赖的两个事物处理同事发生可能导致条件失效，这种错误叫做**写偏序(write skew)**，这种依赖过时的查询结果的效应叫**幻影(phantom)**。

## 序列化
弱孤立等级难以确定，如果不确定需要什么样的弱孤立等级可以直接用`序列化`，
## 事物序列化
序列化的主要缺点是单线程容易成为瓶颈。
序列化需要注意几个地方：
1. 所有事物必须短小快速。
2. 活跃数据不要超过内存限制，不然读写硬盘会堵塞其他事物。
3. 写操作的吞吐量不要超过单CPU的处理能力。
4. 跨分片事物要谨慎使用。

## 二相锁（2PL）
独享和共享两种状态，共享状态下多个读可以同时事物可以一起处理互不影响，写操作时进入独享状态，此时不能读也不能写，此时不能读也不能写。二相锁的序列化如果有个事物时间过长可能会堵塞其他事物。所以每个事物的操作时间一定要慎重考虑。

## 序列快照孤立
二相锁是对操作悲观主义，它假定任何同时操作都可能出错，它的性能代价太大。
序列化则是极度悲观主义，相当于给每个事物一个单独的锁，它难以扩容。
序列快照孤立等级则是乐观主义，假定任何操作都是可行的，只有当出现冲突才解决，解决的方法是回退，只有可以序列化的操作才能入库。如果冲突经常发生乐观主义可能会性能下降很厉害，反之乐观主义的性能会明显好于悲观主义。

## 总结
