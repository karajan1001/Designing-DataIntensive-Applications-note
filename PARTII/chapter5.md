# 第五章 重复
重复表示同一份数据被复制了多次。重复的主要目的有三点：
1. 让数据更接近用户。
2. 增加系统容错性。
3. 增加系统读取数据的性能。

## Leader和Follower
这种系统写都是通过Leader，然后由Leader发送给Follower，读取的时候可以从Leader也可以从Follower读取。 关系型数据库一般使用这种结构，除此外MongoDB等非关系数据库以及Kafka等MQ也使用这种结构。

## 同步和异步
同步表示，Leader更新时必须等Follower更新完才算完成。异步表示Leader可以不用等Follower更新。所有Follower同步会导致可用性急剧下降，所以一般只有Follower同步，当这个Follower不可用时找一个新Follower替代，这样系统一直有一份备份。这种结构叫半同步(semi-synchronous)

## 扩容
扩容或者恢复Follower时先从Leader获得一份Snapshot，拷贝完成后，再同步Snapshot后面的所有信息。

## 处理节点中断
### Follower中断
直接从断点开始请求后面的数据。
### Leader中断
某个Follower会升级为Leader，所有的请求重新定位到新Leader，这个过程叫故障转移(failover)
整个过程一般分为三部分。
1. 确定Leader故障。
2. 选举新Leader。
3. 更新系统配置。

恢复错误时的问题
1. 最简单的办法是丢弃老的leader中的数据，可能会导致数据丢失。
2. 有时候两个node都以为自己是leader，这会导致脑裂（split brain）。
3. 如何设置，timeout也是一个要考虑的的问题。

## 备份log
### statement  备份
最简单的方法：Leader把收到的每条写请求（statement）都发给follower，
这方法可能会因为：
1. now(),rand()等函数。
1. 在自增列，顺序的不同。
1. 有其他依赖。

导致每个备份上的数据不一致。

### Write-ahead log shipping
之前说到数据库存数据时会用一份append only的log文件保存修改。 我们备份时也可以把log文件中每个修改备份，这个方法有个缺点，log文件中依赖磁盘位置等信息，这会导致备份依赖数据库版本，而无法热升级软件版本。

### 逻辑 log 备份
如果把log和存储引擎解锁。

## 备份延迟的问题
单Leader多Follower结构对于写操作少，读操作多的系统有很大好处。不过只有少数node可以同步更新，不然少数节点的错误会导致整个系统的不可用，但是异步更新又会导致数据的不一致，这种状态叫逐步一致。

## Reading Your Own Writes
如果用户提交数据后查询到的结果和自己提交的不一致会引起严重的用户体验问题。这时候需要read-after-write 一致性。这可以保证你看到自己的提交数据实时生效但是不保证其他人。同一个用户使用多个不同设备修改数据要更为谨慎。

## 单调读
单调读比强一致性弱，不过逐步一致要强。需要保证用户每次刷新看到的数据都比上次要更新。一个可行的方法是用户每次刷新都从同一个备份中读取数据。

## 一致前缀读
保证其他用户看到两个先后提交数据的用户提交的顺序正确。

## 多Leader备份
多个Leader都能写数据。多Leader架构一般出现在多数据中心的情况下，不然这种架构得到的好处相比它的复杂性非常有限。多数据中心有如下好处：
1. 用户可以连接就近的数据中心延迟更低。
2. 可以忍受部分数据中心出错。
3. 可以忍受网络问题。
离线服务以及多用户编辑系统和多Leader有相似之处。

## 处理混淆
多Leader系统中多个用户可以同时提交成功，这就可能导致混淆。我们可以同步探测混淆，让每个用户等待提交被其他用户接受，但是这样就丧失了多Leader系统最大的好处。我们可以逃避混淆，每个用户在各自的Leader下工作，实际上这是一些数据中心的做法，但是这没有根本上解决问题。在单Leader系统，不同提交对Leader有先后顺序，多Leader系统则没有这回事，最后的结果就是各Leader没法走向逐步一致。解决方法主要有：
1. LWW：(last write wins)给每个修改一个ID，然后最大的保留，其他丢弃，但是这可能会导致数据丢失。
2. 想办法把两次修改合并。
3. 用某种结构记录每次混淆，之后用规则或者手工解决混淆。

解决混淆一般在两个时间触发：在写时触发，在读时触发。
混淆自动解决的三种方案：
1. Conflict free replicated datatyes.
2. Mergeable persistent data structure.(git)
3.  Operational transformation(google docs)

## 多Leader的拓扑结构
1. 环型：容错率低，需要给修改加上节点标记防止死循环。
2. 星型：容错率低，需要给修改加上节点标记防止死循环。
3. 全连接：需要给修改加上版本号防止出现修改顺序不一致。

## 无Leader结构
Dynamo-style
### 写时异常
写时如果某个节点异常，会导致重启后读取数据读到旧版本，一个可行的解决方案是读请求发送给所有节点，比较不同节点的版本号确定正确的值。写时异常的节点如何修复：
1. 读时修复:当读到某个节点数据落后其他节点时返回一个更新数据的请求给它。
2. 逆熵过程:使用一个后台进程不断搜索缺失的数据。

**法定人数读写**：在**n**个节点中，写必须有**w**个节点确认，读必须有**r**个节点确认：则当等式$$n< w+r$$ 成立叫法定人数读写(quorums reads and writes)。法定人数可以随意调节根据业务需求。可以使得在**w**或者**r**小于**n**时依然能够读写成功。

## 法定一致性的局限性
实际情况更复杂，很多问题可能导致法定一致性成立时依然读到旧的数据。 
### 监控
在有leader的系统中监控有一个标准 ，这使得评估逐步一致性变得简单，而在无leader系统中标准不存在，这使得监控更加复杂。

## 同时写
同时指的是两次操作互相不知道对方存在。*按照相对论：如果两个事件发生超过一定距离，就无法互相影响。同样在计算机系统中如果两次操作互相无法影响他们就是同时的。*
解决方案有：
1. 后写者赢：最后一个写的覆盖前面所有的值，这个方案可能导致值丢失。只有当每次写都有一个新的unique key的话这个方案才是安全。
2. 用版本号探测同时操作。
3. 合并分支：自动合并如果有删除操作需要用一个**墓碑**(tombstone)表示。
4. 多个节点需要多个版本，最后形成版本号向量。

## 总结
讨论了备份的用处：
1. 高可用
1. 离线操作
2. 延迟
3. 伸缩性
三种主要备份方式：
1. 单Leader
2. 多Leader
3. 无Leader
几个需要注意的一致性点：
1. 写后后一致性
2. 单调一致性
