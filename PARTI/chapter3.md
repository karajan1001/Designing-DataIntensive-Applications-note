# 第三章 存储和检索
增加索引会加快搜索，但是第一会耗费更多空间，第二会减慢写入操作。
## Hash index
- 维护方式 ：hash 表是一种key value的数据存储格式。其中key作为索引。哈希表的value可以存于硬盘上，内存中的key存有硬盘上的地址。硬盘上的文件只做append操作，当硬盘上的文件超过一定大小就会进行压缩合并。

哈希表的局限性：
1. 必须保存在内存中。
2. 难以进行范围操作（比大小）。
## Sorted String Table 和 LSM-Trees
排序表的优势，合并很迅速类似merge_sort。维护方法是内存中用平衡树保持排序索引，当索引达到一定大小写入硬盘变成SST文件。查询时先查找内存，后查找硬盘。后台运行一个维护程序不断合并SST文件。
这种索引方法叫log-structured-merge trees
LSM树把数据分成不等大小的块，按照先后顺序生成。
## B-trees
B-树，把数据分成等大小的块，树状结构。数据块中分支的数目叫分支系数**branching factor**。数据块在新增数据超限时会分裂。为了增加数据可靠性，B-树数据库还会有一个append-only的log记录防止出现数据丢失。

## 两者对比
B-树 读快，写慢
LSM-树 读慢，写快 ，压缩比更高，压缩数据的操作可能会影起高延迟，压缩数据太慢可能会引起数据溢出。

内存数据库（比如redis）比硬盘数据库快主要不是因为需要读写硬盘，而是编解码。

## 事物处理和分析
用数据库进行数据处理可能会影响数据库事物处理。这时可以用数据仓库帮忙处理。

## 列存储
因为数据仓库的列经常很多（上百）而一次查询一般只需要几列，所以存储时使用列存储会有更高事物分析的效率。同时压缩也会更有压缩比，处理时因为可以矢量处理也会更快。

## 总结
- **OLTP事物处理**：查询量大，每次处理一小部分。
- **OLAP事物分析**：查询量小，每次处理读取很多数据。

OLTP分两种：
- *日志型*：增量写入
- *覆盖型*：替换写入
