# 第十二章 数据系统的未来
对未来的所有看法当然都是主观的，所以本章的内容只是作者的意思。本书的目标在第一张就已经说明：探索如何构建一个可靠可扩展可维护的系统。

## 数据集成
对于简单的有一组数据希望之后读取的问题，是没有正确答案的，不同的方案对应不同的情况

### combining specialized tools by deriving data

开发者经常会想当然对方想要它不想要它。

#### 数据流的原因
当数据的多份拷贝被存储在不同的数据库中，需要明确它们之间的依赖关系。

#### 数据导入核分布式事物的对比
分布式事物提供了线性一致性，可以保证读到写入的内容。不过分布式事物在容错和性能方面相当薄弱。

#### 完全顺序的局限性
完全顺序性的巨大缺点在于依赖单节点的处理能力。因为顺序要依赖单节点来确定。

### 批处理和流式处理
两者最本质区别在于一个是有界的另一个则是无界的。

#### 保持导出状态

#### 重复计算数据对应用演化的帮助
可以重复计算的历史数据可以帮助我们构建一个全新的数据视图

#### lambda 架构
将批量和流式系统组合起来，流式计算可以用快速的近似算法而批处理数据则可以用更多的容错核更复杂的计算。不过这个架构有几个缺点：
1. 维护多套计算引擎的维护成本。
2. 多套数据需要互相导入。
3. 重跑全量数据需要大量的计算成本。

#### 统一批处理和流式处理

## 非绑定数据流
最高抽象层级下，数据库，Hadoop和操作系统都在做同样的事，存储数据然后对它们操作。Unix更多针对硬件底层，数据库更多针对应用。

### 组合数据存储技术
#### 创建索引
创建一个新的索引的过程很类似创建一个新的备份，然后使用`数据变化捕捉(CDC)`。

#### 万物的元数据库
所有的ETL,batch,stream 数据流，可以被看成是一个'大的'数据库的索引工作。没有一种数据库可以满足我们所有的需求，但是我们可以把两种工具组成一个复合系统。`federated database`和`unbundled database`一个读统一,一个写统一。

#### 让非绑定数据流工作
传统的分布式事物在灵活性上要比事件日志导出的数据弱的多。而且我们可以只对特定消费者行为做顺序排列, 这样会大大减少系统复杂度。

#### 非绑定和集成系统
就算非绑定系统代表未来，他们也不会替代集成数据库，相反会更加依赖它们。非绑定系统会导致学习成本的大大增加，但是它可以可以比传统数据库适应更广的需求。非绑定数据流只在没有一款数据库能满足你全部需求时才应该使用。

#### 什么丢失了
目前我们没有一个可以让数据在不同数据库中统一流动的管道，就如同unix pipe 一样。(数据库可以看成 unix 中的 byte string) 

### 设计围绕非绑定数据库的应用
#### 应用代码作为导入函数
当一个数据集导入另一个数据集时一般都需要一些转化程序比如**第二索引构建**,**全文搜索引擎索引构建**,**机器学习依赖的数据预处理**,**统计的缓存系统**。让数据库执行任意转换代码通常会变得比较困难。

#### 将应用代码与状态独立
讲应用代码与状态独立出来的技术通常会取得比使用数据库自带的UDF更加好的效果。将无状态的代码与有状态的代码分离通常可以获得良好的效果。

#### 数据流:状态改变和应用代码的相互影响
我们可以让状态改变作为应用代码产生数据流的开关。容错是数据流的重要一环，稳定的消息发送与容错是刚性需要，现代流处理可以很好的保持数据流的顺序与可靠性。

#### 流处理与流服务
目前的趋势是将应用开发分解为微服务通过同步网络请求进行。这样的好处是可以让 不同团队不同应用解耦。有效的降低相互之间的交互。将流处理组合成数据流系统与微服务有很多相似之处，不过他们之下的通信方式有本质不同一个同步一个异步。流处理不光可以更好的容错也能提高性能。

### 观察导出数据
数据从入库到被读取的过程由写路径与读路径组成。写路径是构建缩影的过程，读路径是只有用户请求过来时发生的过程。而我们的数据集则是读路径与写路径的交汇处。

#### 素材视图与缓存
完全不预先计算请求与事先计算好任何请求都是不可行的。一个折中办法是预先计算好常见的请求，这就是素材视图或者缓存的作用。所以数据集索引并不是读写路径交汇的唯一位置。我们可以通过改变读写路径的交汇点来应对不同类型的请求从而达到更好的性能。

#### 无状态离线客户端
这种读写路径交汇处的移动同样发声在客户端-服务端模型中。传统客户端都是无状态的，而数据全部保持在服务端上。而在最近的应用中，客户端开始承担越来越多的缓存计算逻辑。

#### 状态变化推送到客户端
传统服务端只能主动接受请求，而最近的TCP连接可以让你在一连上网的瞬间就将服务端的数据同步到客户端。

#### 端到端事件流
很多及时通信软件都支持事件流，但是很多其他应用无法做到，因为这要求它们从请求回复架构转为发表订购数据流。订购变化很多时候比仅仅查询当前状态更为有效。

#### 读也是一种事件
我们还能更进一步将读写都看成事件，而它们最终会在某处融合最后形成新的事件返回到读的出发点。

#### 多区块数据处理
读作为事件流还提供了多区块数据处理的可能性。

## 目标纠错
对于有状态的服务，纠错就变得非常重要。大量工具理论已经投入该领域，应对不同的场景我们需要使用不同的工具。

### 数据库的端到端实参
就算应用使用了一个相对更安全的数据系统，也不能保证数据丢失，比如程序存在BUG等。这些问题在只增不改的数据库中更容易恢复。

#### 只操作一次
重复提交会导致数据冗余，一个有效的方法是使得操作具有幂等性。

#### 重复抑制
因为，就算我们使用了事物处理或者二项提交等方法，用户也可能因为没有收到正确的反馈而手动重复提交导致数据冗余。
```sql
BEGIN TRANSACTION;
UPDATE accounts SET balance = balance + 11.00 WHERE account_id = 1234;
UPDATE accounts SET balance = balance - 11.00 WHERE account_id = 4321;
COMMIT; 
```

#### 操作标识符
为了保证操作幂等，我们可以使用操作标识符。比如使用客户端以及当前状态的HASH值。比如在操作前加入
```sql
ALTER TABLE requests ADD UNIQUE (request_id);
BEGIN TRANSACTION;
INSERT INTO requests
(request_id, from_account, to_account, amount)
VALUES('JFJZN9123EMASDFJPOAMSDF', 4321, 1234, 11.00);
UPDATE accounts SET balance = balance + 11.00 WHERE account_id = 1234;
UPDATE accounts SET balance = balance - 11.00 WHERE account_id = 4321;
COMMIT; 
```
可以保证操作的唯一性，而且可以作为只增日志

#### 端到端实参
要解决数据重复问题，我们需要一种端到端的思想，从TCP,到分布式数据到用户终端共同出力解决这个问题。

#### 在数据系统中使用端到端思想
底层的容错算法已经相对完善，不过在更高的曾经我们目前还没有一套可行的抽象方法来对付纠错问题。事物虽然不错，但是它代价过于高昂以至于我们无法在所有场景使用它。

### 强化约束
我们的应用需要满足很多约束，座位只有一个，金额不能为负等等。本节主要介绍强化这些约束的技术。

#### 唯一性约束需要共识
最简单的唯一性约束实现方式就是使用单leader模式，不过这个模式会受到单节点性能束缚。另一个可能方式就是对需要满足唯一条件的字段进行分区。不过如果节点有多个备份，则同步不可避免。

#### 日志信息中的唯一性
日志系统可以保证完全顺序性，所以可以很容易解决唯一性问题

#### 多分区请求处理
使用分区化的日志，而不是原子操作也可以达到同样的效果。

### 及时性与完整性
使用事物的一个好处是及时性，修改马上可以看到，而日志类数据系统则没有这样的好处。一致性这个说法其实混淆了两个概念`及时性`和`完整性`。如果无法满足及时性而只能满足完整性的系统可以称为满足最终一致性。

#### 数据流系统的纠错
分布式事物同时满足及时性核完整性，但是会对性能有很大的损害，基于日志的系统，放弃及时性，将完整性保证放到本地处理，极大的提升了性能。我们利用一套方法满足完整性。 所有消息来源都记录在单一日志上，其他所有的状态都能从日志确定性导出。每个请求，都满足端到端去重和幂等，所有消息都只能导出而不能修改。

#### 松的完整性约束
在某些场景完整性约束没那么强的要求，偶尔的错误可以通过道歉沟通解决。此时可以放弃严格的完整性约束。

#### 避免协调数据系统　
数据流系统可以避免原子提交或者分布式事物中的数据协调，从而大幅提高性能。协调和完整性约束可以减少道歉的次数。同样也会大幅降低性能和可用性，我们需要在其中找到平衡点。

### 信任然后验证
我们之前所提到的模型被称为系统模型，它假设某些事件可能出错，而另一些比如硬盘中的数据，cpu计算结果等永远不会出错。不过随机的比特错误确实偶尔会出现，它并不是绝不可能发生的事情。

#### 在硬件可能出错时保持数据完整性
虽然很少发生，但是类似Mysql这样的软件也是会出现BUG的。更多的错误则出现在应用代码的缺陷上，还有应用代码对数据库等的错误使用。

#### 不要盲目相信他们的保证
因为硬件和软件的错误无法避免，所以我们至少应有一种方法检测到他们的存在。成熟的系统会考虑到硬件的错误比如HDFS等等。

#### 验证的文化
本小节作者希望以后更多的软件能提供自我检测的功能

#### 自验设计
事物设计相比日志记录更不容易自我验证。因为他们拥有确定性和可重复性。

#### 端到端实参
自验需要包含更多的部分，最好实现端到端，包含的部分越多，覆盖的软硬件问题就越广，我们对系统的信心就越足。

#### 自验的工具
最近一大堆密码学工具被发明出来用来帮助实现校验。比如加密货币或者区块链等等。这些技术大多基于Merkle Tree，它也被广泛应用于SSL/TLS等等协议，可以想象未来类似技术会在数据系统中发挥更大的功效。

## 做正确的事
