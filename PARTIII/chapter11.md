# 第十一章 流式计算

上一章批量处理中所有数据都是有界的。一个方法是将数据分成`chunk`但是这样处理结果会有延迟。对于一些实时性要求更高的工作，可以将其当做数据流处理。

## 传递事件流
流式计算的输入是一个个，小的自洽的不可变的事件。批量计算中，数据被写入到一个文件，然后被多个计算任务读取。而流式计算中，事件被一个生产者`producer`生产，然后被多个消费者`consumer`消费。批量处理中的消费者需要主动拉取数据，这样命中率很低，流式计算生产者主动推送数据，这样可以减少为了低延迟而进行的高频无效查询次数。关系型数据库对于这种推送方式支持不好，这是引入流式计算专门工具的一个重要原因。

### 消息系统
普通的Unix系统消息支持单对单，或者多对单的消息发送。不过一个消息系统支持，多个生产者将消息发送到同一个topic然后由多个消费者消费这个topic中的消息。一个消息系统要关注两个问题：

1. 如果消费者消费速度跟不上生产者生产速度会怎么样。特别是当缓存逐渐增长直到占满整个内存。消息是否会丢失。(三种措施: 丢弃，缓存，限流)
2. 如果系统崩溃，未发送的消息是否会丢失。

#### 信息在生产者和消费者之间的直接传递
很多消息系统直接在生产者和消费者之间传递消息。有低延迟的UDP，无broker的ZeroMQ，收集所有机器的UDP的statsD和Brubeck。还有消费者直接暴露HTTP，RPC协议。这些直接模式有个缺点，如果网络存在问题，消息可能会丢失。

#### 消息broker
又叫消息队列，是用来处理信息流的数据库。它可以将所有消息丢失问题集中到自己处处理。这样带来另一个异步处理的特性，生产者只要将消息给broker就可以去干其他事情。

#### 消息队列和数据库对比

- 消息队列中数据不会长期保留。
- 队列大小不会太大。
- 队列使用主题匹配方式，数据库采用索引匹配。
- 消息队列不能查询，但是会通知消费者数据变化。

#### 多消费者
有两种常用逻辑

- 负载均衡
- fan-out(广播类似)

#### 重新发送
因为消费者可能会出现错误，所以消费者必须返回broker消息处理成功与否。如果超时broker需要重新发送请求。不过因为回执也可能丢失，所以也许实际上消费者已经成功处理了请求。更常见的问题是重新发送的消息在队列中的顺序会出现错乱。

### 分布日志
消息队列和数据库还有文件系统一个很大不同是不会存历史数据，如果出现错误无法恢复重跑。

#### 用日志保存消息
一个可行的解决方案是使用文件日志保存消息数据，Kafka,Kinesis Stream, DistributedLog都是这样的解决方案。而且他们写文件系统使用分布式写的方式（同一分区内部时间顺序可以比较, 不同分区无法比较)。这些系统可以支持百万条消息每秒的吞吐量。

#### 基于log的消息队列和传统消息队列比较
这种消息队列会把一整块数据都给consumer,不过里面会记录上consumer需要处理的条目达到负载均衡。这种方式如果遇到某条消息处理时间较长，可能后面所有消息都会被堵塞，所以对于处理缓慢任务最好使用传统方式，一条一条发送消息，而如果需要大吞吐量，对顺序比较在意则可以使用一整块一起发送的方式。

#### 消费者offset
这个系统中，消息队列类似一个leader,而消费者类似一个worker。leader需要记录消费者消费的offset.之前的全部处理过，之后的全部没有处理。

#### 硬盘使用

#### 如果消费者跟不上生产者的进度
在日志消息队列中，人们有充分时间在发生报警后处理问题。

#### 重新计算老消息
而且历史数据也可以冲盘，这是相对传统消息队列的一个大优势。

## 数据库和流
